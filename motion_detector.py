
# motion_detector_pyqt5.py
# Converted from tkinter to PyQt5 while keeping non-GUI logic unchanged.
# NOTE: This file was auto-generated by ChatGPT. Verify and test on your environment.
import cv2
import time
import numpy as np
import os
import requests
import subprocess
import platform
import logging
import threading
import asyncio
import signal
import tracemalloc
import sys
import smtplib
import traceback
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email.mime.text import MIMEText
from email import encoders
from datetime import datetime, timedelta
from dotenv import load_dotenv
from moviepy import VideoFileClip
from threading import Thread
from logging.handlers import TimedRotatingFileHandler
from telegram.ext import Application, CommandHandler, ContextTypes
from contextlib import contextmanager
from PyQt5.QtGui import QImage, QPixmap
from PyQt5.QtCore import QObject, pyqtSignal

class GuiUpdater(QObject):
    # Define a signal that can carry any callable function
    update_signal = pyqtSignal(object, tuple, dict)

    def __init__(self):
        super().__init__()
        self.update_signal.connect(self.execute_in_main_thread)

    def execute_in_main_thread(self, func, args, kwargs):
        # This slot executes in the main thread context
        func(*args, **kwargs)

gui_updater = GuiUpdater()

# PyQt5 imports
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QPushButton, QLabel, QVBoxLayout,
    QMessageBox, QTextEdit, QSizePolicy
)
from PyQt5.QtCore import QTimer, Qt

# Global state variables
tracemalloc.start()
gui_active = True
daily_summary_enabled = True
detection_thread = None
telegram_thread = None # Initialize globally
cap = None
telegram_app = None
telegram_loop = None # We will now manage this manually for the background thread
shutdown_event = threading.Event()
# Qt objects
app = None
main_window = None
widgets = {}
start_button = None
stop_button = None
cooldown_label = None
on_close = None 
autostart_enabled = True  # Set to False to disable autostart
autostart_status_label = None
autostart_animation_active = False
detection_active_event = threading.Event()
last_motion_time = None
motion_count_today = 0
video = None
telegram_bot_running = False
telegram_bot_loop = None # Reference to the asyncio event loop for clean shutdown
watchdog_stop_event = threading.Event() # CRITICAL: Event to signal the watchdog to stop
telegram_loop_stop_event = threading.Event()
watchdog_thread = None
active_timers = []

log_handler = TimedRotatingFileHandler(
    "motion_log.txt", when="midnight", interval=1, backupCount=7
)

logging.basicConfig(
    level=logging.INFO,
    handlers=[log_handler],
    format="%(asctime)s [%(levelname)s] %(message)s",
)

logging.info("App started")

dotenv_path = os.path.join(os.getcwd(), ".env")
if not os.path.exists(dotenv_path):
    # Fallback for when the .desktop file's Path setting is ignored or failed
    dotenv_path = "/opt/motion-detector/.env"

load_dotenv(dotenv_path=dotenv_path)

autostart_raw = os.getenv("AUTOSTART_ENABLED", "False")
autostart_enabled = autostart_raw.strip().lower() == "true"

TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")


def send_fastmail_email_with_attachment(
    subject: str,
    body: str,
    to_email: str,
    video_path: str,
    from_email: str,
    app_password: str
):
    # Create the email container
    msg = MIMEMultipart()
    msg["From"] = from_email
    msg["To"] = to_email
    msg["Subject"] = subject

    # Attach the body text
    msg.attach(MIMEText(body, "plain"))

    # Attach the video file
    if os.path.exists(video_path):
        with open(video_path, "rb") as f:
            part = MIMEBase("application", "octet-stream")
            part.set_payload(f.read())
            encoders.encode_base64(part)
            part.add_header(
                "Content-Disposition",
                f'attachment; filename="{os.path.basename(video_path)}"'
            )
            msg.attach(part)
    else:
        print(f"[!] Video file not found: {video_path}")
        return

    # Send the email via Fastmail SMTP
    try:
        with smtplib.SMTP("smtp.fastmail.com", 587) as server:
            server.starttls()
            server.login(from_email, app_password)
            server.send_message(msg)
        print("[‚úÖ] Email sent successfully.")
    except Exception as e:
        print(f"[!] Failed to send email: {e}")



def gui_exists():
    #print(f"main_window: {main_window} and main_window.isVisible: {main_window.isVisible()}")
    if main_window is not None and main_window.isVisible():
        #print("Returning True from gui_exists()")
        return True
    else:
        return False
        
def gui_after(ms, func, *args, **kwargs):
    # gui_exists() is still required to check if the main window exists
    if gui_exists():
        #print(f"[DEBUG] gui_after scheduling function via Signal for {ms}ms")
        
        # 1. If delay (ms) > 0, use a QTimer to introduce a delay before emission.
        if ms > 0:
            # We wrap the signal emission in a lambda function for QTimer
            QTimer.singleShot(ms, lambda: gui_updater.update_signal.emit(func, args, kwargs))
        
        # 2. If delay (ms) == 0, emit the signal immediately.
        # This queues the function for the next available slot in the main event loop.
        else:
            gui_updater.update_signal.emit(func, args, kwargs) 

    else:
        # Fallback to standard Python Timer if the GUI is not active (e.g., headless mode)
        #print("[DEBUG] gui_after fallback triggered")
        # Ensure the Timer starts the function with arguments
        def delayed_start():
            time.sleep(ms / 1000.0)
            logging.info(f"[TIMER] Delayed start for: {func.__name__}")
            Thread(target=func, args=args, kwargs=kwargs, daemon=True, name=f"{func.__name__}Worker").start()

        t = Thread(target=delayed_start, daemon=True, name=f"{func.__name__}Delay")
        t.start()
        active_timers.append(t)


def _set_cooldown_label_text(label, seconds_left):
    if label:
        label.setText(f"Cooldown: {seconds_left}s")

def update_cooldown_label(seconds_left):
    """Updates the cooldown label thread-safely."""
    #print(f"update_cooldown_label function - detection_active_event.is_set(): {detection_active_event.is_set()} and gui_exists(): {gui_exists()}")
    if not detection_active_event.is_set() or not gui_exists() or cooldown_label is None:
        print(f"cooldown_label: {cooldown_label}")
        return
    gui_after(0, lambda s=seconds_left: _set_cooldown_label_text(cooldown_label, s))

def _toggle_autostart_label_color(label):
    """Toggles the background color of the autostart status label (Qt version)."""
    if not label:
        return

    current_style = label.styleSheet() or ""
    # Toggle between green and limegreen
    if "limegreen" in current_style:
        label.setStyleSheet("background-color: green;")
    else:
        label.setStyleSheet("background-color: limegreen;")

def animate_autostart_indicator():
    global autostart_animation_active

    if not autostart_enabled or not autostart_animation_active:
        return

    if not gui_exists():
        return

    _toggle_autostart_label_color(autostart_status_label)

    # Schedule next blink
    gui_after(500, animate_autostart_indicator)

def update_gui_idle_state():
    """Updates GUI components to reflect idle state."""
    if not gui_exists():
        return
    if cooldown_label:
        cooldown_label.setText("Idle")
    if stop_button:
        stop_button.setEnabled(False)
    if start_button:
        start_button.setEnabled(True)
        
def release_camera_resource():
    """Safely releases the camera if it's open."""
    global cap
    if cap is not None and hasattr(cap, "isOpened") and cap.isOpened():
        cap.release()
        cap = None
        print("[üì∑] Camera resource released.")
        time.sleep(1.0)  # Give time for driver to settle
        
def shutdown_detection_pipeline(remote=False):
    global detection_active_event, detection_thread
    detection_active_event.clear()
    print("[üõë] Detection flag set to False.")


    if detection_thread and detection_thread.is_alive():
        detection_thread.join(timeout=5)
        if detection_thread and detection_thread.is_alive():
            logging.warning("Detection thread failed to join gracefully.")
            if not remote and cooldown_label:
                cooldown_label.setText("‚ö†Ô∏è Detection thread hang")
                def clear_warning():
                    if cooldown_label:
                        cooldown_label.setText("")
                gui_after(10000, clear_warning)

    detection_thread = None  # ‚úÖ Add this line to allow restart
    update_gui_idle_state()
    logging.info("Motion detection stopped.")
    detection_active_event.clear()
    
async def status_command(update, context):
    """Handles the /status command to report system health."""
    global last_motion_time

    chat_id = update.message.chat_id
    try:
        expected_id = int(TELEGRAM_CHAT_ID)
    except (TypeError, ValueError):
        expected_id = -1

    if chat_id != expected_id:
        logging.warning(f"Unauthorized status request from chat ID: {chat_id}")
        await update.message.reply_text("Unauthorized access.")
        return

    status_lines = []

    # GUI status
    if gui_exists():
        status_lines.append("‚úÖ GUI is active")
    else:
        status_lines.append("‚ö†Ô∏è GUI is not responding")

    # Detection thread
    if detection_active_event.is_set():
        if detection_thread and detection_thread.is_alive():
            status_lines.append("‚úÖ Detection thread running")
        else:
            status_lines.append("‚ùå Detection thread missing")
    else:
        status_lines.append("üõë Detection is idle")

    # Telegram thread
    if telegram_app and getattr(telegram_app, "running", False):
        if telegram_thread and telegram_thread.is_alive():
            status_lines.append("‚úÖ Telegram thread running")
        else:
            status_lines.append("‚ùå Telegram thread missing")
    else:
        status_lines.append("üõë Telegram listener is stopped")

    # Last motion detection time
    if last_motion_time:
        formatted_time = last_motion_time.strftime("%Y-%m-%d %H:%M:%S")
        seconds_ago = int((datetime.now() - last_motion_time).total_seconds())
        minutes, seconds = divmod(seconds_ago, 60)
        time_ago_str = f"{minutes}m {seconds}s ago" if minutes else f"{seconds}s ago"
        status_lines.append(f"üì∏ Last motion detected at: {formatted_time} ({time_ago_str})")
        status_lines.append(f"üìà Motion events count today: {motion_count_today}")

    else:
        status_lines.append("üì∏ No motion detected yet")

    # Compose and send
    summary = "üìä System Status:\n" + "\n".join(status_lines)
    await update.message.reply_text(summary)
        
async def summary_command(update, context):
    """Handles the /summary command to report motion activity for today."""
    global last_motion_time, motion_count_today

    chat_id = update.message.chat_id
    try:
        expected_id = int(TELEGRAM_CHAT_ID)
    except (TypeError, ValueError):
        expected_id = -1

    if chat_id != expected_id:
        logging.warning(f"Unauthorized summary request from chat ID: {chat_id}")
        await update.message.reply_text("Unauthorized access.")
        return

    today = datetime.now().strftime("%Y-%m-%d")
    summary_lines = [f"üìÖ Motion Summary for {today}"]

    # Motion count
    summary_lines.append(f"üìà Motion events today: {motion_count_today}")

    # Last motion time
    if last_motion_time:
        formatted_time = last_motion_time.strftime("%Y-%m-%d %H:%M:%S")
        seconds_ago = int((datetime.now() - last_motion_time).total_seconds())
        minutes, seconds = divmod(seconds_ago, 60)
        time_ago_str = f"{minutes}m {seconds}s ago" if minutes else f"{seconds}s ago"
        summary_lines.append(f"üì∏ Last motion detected at: {formatted_time} ({time_ago_str})")
    else:
        summary_lines.append("üì∏ No motion detected yet")

    # Last 5 log entries (optional)
    try:
        with open("motion_log.txt", "r") as f:
            lines = [line.strip() for line in f.readlines() if today in line and "Motion detected" in line]
        if lines:
            summary_lines.append("üßæ Recent motion events:")
            summary_lines.extend(lines[-5:])
        else:
            summary_lines.append("üßæ No logged motion events yet.")
    except Exception as e:
        logging.error(f"Failed to read motion log for summary: {e}")
        summary_lines.append("‚ö†Ô∏è Could not read motion log.")

    # Send summary
    await update.message.reply_text("\n".join(summary_lines))
    
def update_telegram_status_label():
    """Updates the Telegram bot status label in the GUI."""
    if not gui_exists():
        return
    if "telegram_status" not in widgets:
        return

    label = widgets["telegram_status"]
    if telegram_bot_running:
        label.setText("Telegram Bot: Online")
        label.setStyleSheet("color: green;")
    else:
        label.setText("Telegram Bot: Offline")
        label.setStyleSheet("color: darkred;")

def shutdown_telegram_listener():
    """Stops the Telegram listener and joins its thread."""
    global telegram_app, telegram_loop, telegram_thread

    if telegram_app and telegram_loop and telegram_loop.is_running():
        print("[üõë] Scheduling Telegram application stop...")

        # ‚úÖ Stop polling first
        asyncio.run_coroutine_threadsafe(telegram_app.updater.stop(), telegram_loop)

        # ‚úÖ Then stop the app
        asyncio.run_coroutine_threadsafe(telegram_app.stop(), telegram_loop)

        # ‚úÖ Finally shut down internal resources
        asyncio.run_coroutine_threadsafe(telegram_app.shutdown(), telegram_loop)

    if telegram_thread and telegram_thread.is_alive():
        print("[üõë] Waiting for Telegram thread to shut down...")
        telegram_thread.join(timeout=5)

        
def shutdown_gui():
    """Destroys the GUI window if active."""
    global main_window, app
    if main_window and main_window.isVisible():
        main_window.close()
       
def stop_autostart_animation():
    global autostart_animation_active
    autostart_animation_active = False
    if autostart_status_label:
        autostart_status_label.setStyleSheet("background-color: green;")  # Set to solid green
    logging.info("Autostart animation stopped after 10 seconds.")
        
@contextmanager
def open_video_writer(path, fourcc, fps, frame_size):
    writer = cv2.VideoWriter(path, fourcc, fps, frame_size)
    try:
        yield writer
    finally:
        if writer:
            writer.release()
    
def safe_imshow(frame):
    """Thread-safe PyQt5 frame display."""
    global widgets
    #print("[DEBUG] safe_imshow called")
    
    init_widgets_for_boot()
    
    if frame is None:
        print("[DEBUG] Frame is None")
        return
        
    if frame.shape[0] == 0 or frame.shape[1] == 0:
        logging.warning(f"safe_imshow received empty frame: shape={frame.shape}")
        return

    if not gui_active or "video_label" not in widgets:
        print("[DEBUG] either gui_active is false or video_label absent in widgets")
        return

    try:
        frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        logging.debug(f"Converted frame to RGB: shape={frame_rgb.shape}")
        #print(f"Converted frame to RGB: shape={frame_rgb.shape}")
        h, w, ch = frame_rgb.shape
        bytes_per_line = ch * w
        qimg = QImage(frame_rgb.data, w, h, bytes_per_line, QImage.Format_RGB888)
        logging.debug(f"Created QImage: size={qimg.width()}x{qimg.height()}")
        #print(f"Created QImage: size={qimg.width()}x{qimg.height()}")
        pixmap = QPixmap.fromImage(qimg).scaled(
            widgets["video_label"].size(),
            Qt.KeepAspectRatio,
            Qt.SmoothTransformation
        )
        logging.debug(f"Scaled pixmap to label size: {widgets['video_label'].size()}")
        #print(f"Scaled pixmap to label size: {widgets['video_label'].size()}")

        # ‚úÖ Use Qt's thread-safe signal queue
        def update_pixmap():
            if "video_label" in widgets:
                #print("[DEBUG] update_pixmap triggered")
                widgets["video_label"].setPixmap(pixmap)
        gui_after(0, update_pixmap)
                
    except Exception as e:
        logging.warning(f"Failed to update video frame: {e}")
           
def save_clip(cap_instance, duration=5, fps=20):
    """Records a video clip from the camera."""
    os.makedirs("clips", exist_ok=True)
    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    avi_path = f"clips/motion_{timestamp}.avi"

    if not cap_instance or not cap_instance.isOpened():
        print("[!] Failed to access webcam during clip save.")
        return None

    width = int(cap_instance.get(cv2.CAP_PROP_FRAME_WIDTH))
    height = int(cap_instance.get(cv2.CAP_PROP_FRAME_HEIGHT))
    fourcc = cv2.VideoWriter_fourcc(*"DIVX")

    frames_recorded = 0
    start_time = time.time()
    with open_video_writer(avi_path, fourcc, fps, (width, height)) as out:
        while time.time() - start_time < duration:
            if not detection_active_event.is_set():
                break

            ret, frame = cap_instance.read()
            if not ret:
                break

            out.write(frame)
            frames_recorded += 1
            
            #print(f"gui_active: {gui_active}")
            if gui_active:
                safe_imshow(frame)
                    
    if frames_recorded > 0:
        print(f"[‚úî] Saved motion clip with {frames_recorded} frames to {avi_path}")
        return avi_path
    else:
        if os.path.exists(avi_path):
            os.remove(avi_path)
        print("[!] Clip save failed (0 frames recorded).")
        return None

def compress_video(input_path, target_size_mb=25):
    """Compresses the AVI video to MP4 using moviepy."""
    if not input_path or not os.path.exists(input_path):
        logging.warning("Input video path is invalid or missing.")
        return None

    time.sleep(0.5)  # Ensure file handle is released

    base, _ = os.path.splitext(input_path)
    output_path = f"{base}.mp4"

    try:
        with VideoFileClip(input_path) as clip:
            duration = clip.duration
            if duration == 0:
                logging.warning("Video duration is zero. Skipping compression.")
                return input_path

            target_bitrate_kbps = (target_size_mb * 8 * 1024) / duration

            clip.write_videofile(
                output_path,
                codec="libx264",
                bitrate=f"{int(target_bitrate_kbps)}k",
                logger=None,
                audio_codec="aac"
            )

        os.remove(input_path)
        logging.info(f"Compressed and converted to MP4: {output_path}")
        return output_path

    except Exception as e:
        logging.error(f"moviepy compression failed: {e}. Retaining original AVI.")
        return input_path

def send_daily_summary():
    """Compiles and sends a summary of motion events for the day."""
    try:
        with open("motion_log.txt", "r") as f:
            lines = f.readlines()

        today = datetime.now().strftime("%Y-%m-%d")
        summary_lines = [
            line for line in lines if today in line and "Motion detected" in line
        ]

        if summary_lines:
            summary = f"üìπ Motion Summary for {today} (Last 10 Events):\n" + "".join(
                summary_lines[-10:]
            )
        else:
            summary = f"üìπ No motion detected on {today}."

        send_telegram_alert(summary)
        logging.info("Daily summary sent via Telegram.")

    except Exception as e:
        logging.error(f"Failed to send daily summary: {e}")

def run_and_reschedule_summary():
    """Runs the summary and schedules the next run."""
    global motion_count_today
    motion_count_today = 0
    send_daily_summary()
    schedule_daily_summary()

def schedule_daily_summary():
    """Schedules the daily summary to run at midnight."""
    if not daily_summary_enabled:
        logging.info("Daily summary disabled. Skipping schedule.")
        return

    now = datetime.now()
    next_run = now.replace(hour=23, minute=59, second=0, microsecond=0)

    if next_run < now:
        next_run += timedelta(days=1)

    delay = (next_run - now).total_seconds()

    def delayed_summary_launcher():
        logging.info(f"[TIMER] Sleeping for {delay:.2f} seconds before launching summary.")
        time.sleep(delay)
        logging.info("[TIMER] Callback starting.")
        Thread(target=run_and_reschedule_summary, name="DailySummaryWorker", daemon=True).start()
        logging.info("[TIMER] Callback offloaded.")

    # ‚úÖ Launch the delay thread instead of using Timer
    t = Thread(target=delayed_summary_launcher, name="DailySummaryDelay", daemon=True)
    t.start()
    active_timers.append(t)
    logging.info(f"Daily summary scheduled for: {next_run.strftime('%Y-%m-%d %H:%M:%S')}")



def clean_old_clips(folder="clips", days=7):
    """Deletes video clips older than a specified number of days."""
    if not os.path.exists(folder):
        print(f"[üßπ] Clip folder '{folder}' does not exist. Skipping cleanup.")
        return
        
    now = time.time()
    cutoff = now - (days * 86400) # 7 days in seconds
    logging.info(f"Starting cleanup of clips older than {days} days.")
    
    for filename in os.listdir(folder):
        filepath = os.path.join(folder, filename)
        if os.path.isfile(filepath):
            try:
                if os.path.getmtime(filepath) < cutoff:
                    os.remove(filepath)
                    print(f"[üßπ] Deleted old clip: {filename}")
            except Exception as e:
                print(f"[!] Failed to delete {filename}: {e}")

# ----------------- Thread and GUI Control Functions -----------------

def run_launch_detection_on_main_thread():
    """Queues launch_detection to run in the main thread using Qt's event loop."""
    if gui_exists():
        gui_after(0, launch_detection)
        logging.info("Scheduled launch_detection on main (Qt) thread.")
    else:
        logging.warning("GUI not running, attempting direct launch_detection call.")
        detection_active_event.set()
        
def run_remote_stop_detection_on_main_thread():
    """Queues remote_stop_detection to run in the main thread using Qt's event loop."""
    if gui_exists():
        gui_after(0, remote_stop_detection)
        logging.info("Scheduled remote_stop_detection on main (Qt) thread.")
    else:
        logging.warning("GUI not running, attempting direct remote_stop_detection call.")
        remote_stop_detection()
        
def launch_detection():
    """Starts the motion detection thread."""
    logging.info("launch_detection() called")
    print("launch_detection() called")
    global detection_thread
    
    if detection_thread and detection_thread.is_alive():
        print("[!] Detection already running.")
        return

    detection_active_event.set()
    print("[‚ñ∂Ô∏è] Starting detection thread.")

    # Start the thread
    detection_thread = Thread(target=main, daemon=True)
    detection_thread.start()
    logging.info("Motion detection started.")

def remote_stop_detection():
    """Gracefully stops detection WITHOUT a confirmation dialog (for remote use)."""
    shutdown_detection_pipeline(remote=True)
    
def stop_detection():
    if not gui_exists():
        shutdown_detection_pipeline(remote=False)
        return
    answer = QMessageBox.question(main_window, "Confirm Stop", "Are you sure you want to stop detection?",
                                  QMessageBox.Yes | QMessageBox.No)
    if answer != QMessageBox.Yes:
        print("[‚Ü©Ô∏è] Stop canceled.")
        return

    shutdown_detection_pipeline(remote=False)

def start_watchdog(interval=5):
    """Starts a background watchdog thread to monitor GUI and thread health."""
    def watchdog_loop():
        while gui_active:
            # 1. GUI health
            if main_window and not main_window.isVisible():
                logging.warning("[üëÅÔ∏è‚Äçüó®Ô∏è] GUI window no longer exists.")
            
            # 2. Detection thread health
            if detection_active_event.is_set():
                if not detection_thread or not detection_thread.is_alive():
                    logging.error("[‚ö†Ô∏è] Detection thread is not alive while detection is active.")
                    send_telegram_error_alert("‚ö†Ô∏è Detection thread died unexpectedly.")

            # 3. Telegram thread health
            if telegram_app and getattr(telegram_app, "running", False):
                if not telegram_thread or not telegram_thread.is_alive():
                    logging.error("[‚ö†Ô∏è] Telegram thread is not alive while app is running.")
                    send_telegram_error_alert("‚ö†Ô∏è Telegram listener thread died unexpectedly.")

            time.sleep(interval)

    Thread(target=watchdog_loop, daemon=True).start()
    logging.info("Watchdog thread started.")

async def shutdown_telegram_listener():
    global telegram_app, telegram_bot_running

    try:
        if telegram_app:
            logging.info("[üõë] Stopping Telegram polling...")
            await telegram_app.updater.stop()         # ‚úÖ Stop polling first

            logging.info("[üõë] Stopping Telegram app...")
            await telegram_app.stop()                 # ‚úÖ Then stop the app

            logging.info("[üõë] Shutting down Telegram app...")
            await telegram_app.shutdown()             # ‚úÖ Finally shut down resources

            telegram_bot_running = False
            logging.info("[‚úÖ] Telegram bot shutdown complete.")
    except Exception as e:
        logging.warning(f"[‚ö†Ô∏è] Telegram shutdown error: {e}")        
        
async def stop_telegram_bot():
    global telegram_app
    if telegram_app:
        await telegram_app.updater.stop()
        await telegram_app.stop()
        await telegram_app.shutdown()

def start_telegram_thread_sync():
    """
    Synchronous wrapper to manually create and run the asyncio event loop 
    for the Telegram listener in a background thread.
    """
    global telegram_loop
    
    if telegram_app and getattr(telegram_app, "running", False):
        logging.warning("Telegram bot is already running. Skipping startup.")
        return

    # 1. Create and set a new event loop for this thread
    try:
        if sys.is_finalizing():
            logging.warning("Interpreter is shutting down. Skipping Telegram loop startup.")
            return

        if not TELEGRAM_TOKEN or not TELEGRAM_CHAT_ID:
            logging.error("Telegram credentials missing.")
            return

        telegram_loop = asyncio.new_event_loop()
        asyncio.set_event_loop(telegram_loop)
        logging.info("[‚úÖ] Telegram loop created and set in background thread.")

        # 2. Run the async listener coroutine until it completes (when polling stops)
        logging.info("Telegram listener loop starting...")
        telegram_loop.run_until_complete(run_telegram_listener())

    except RuntimeError as e:
        logging.error(f"Telegram loop failed: {e}")
    except Exception as e:
        logging.error(f"Telegram loop failed: {type(e).__name__}: {e}")
        print(f"[‚ùå] Exception in Telegram loop thread: {e}")
    finally:
        # 3. Cleanup the loop
        if telegram_loop:
      
            if telegram_loop and telegram_loop.is_running():
                telegram_loop.call_soon_threadsafe(telegram_loop.stop)
                time.sleep(0.5)  # Give it time to stop
                telegram_bot_loop.run_until_complete(stop_telegram_bot())
                telegram_loop.close()
            try:
                telegram_loop.run_until_complete(shutdown_telegram_listener())
                logging.info("[‚úÖ] Telegram listener loop terminated.")
            except Exception as e:
                logging.warning(f"Error during Telegram loop cleanup: {e}")
        logging.info(f"[üßπ] Telegram loop is running: {telegram_loop.is_running()}")
        telegram_loop = None

def force_exit(signum=None, frame=None):
    """Forces immediate termination of the application process."""
    global detection_active_event, telegram_bot_loop

    print(f"\n[üõë] Received exit signal {signum}. Initiating force exit.")

    try:
        if telegram_bot_loop and telegram_bot_loop.is_running():
            asyncio.run_coroutine_threadsafe(shutdown_telegram_listener(), telegram_bot_loop)
        else:
            asyncio.run(shutdown_telegram_listener())
    except Exception as e:
        logging.warning(f"Telegram shutdown failed: {e}")

    if telegram_thread and telegram_thread.is_alive():
        telegram_thread.join(timeout=5)

    release_camera_resource()
    shutdown_gui()

    print("[üíÄ] Forcing system exit.")
    #os._exit(0)
    sys.exit(0)
    
# ----------------- Telegram Listener -----------------

async def start_command(update, context):
    """Handles the /start_detector command from Telegram."""
    chat_id = update.message.chat_id
    
    # --- CRITICAL DEBUGGING ---
    print(f"\n[‚ùì] Received /start_detector from chat ID: {chat_id}")
    try:
        expected_id = int(TELEGRAM_CHAT_ID)
        print(f"[‚ùì] Expected authorized chat ID from .env: {expected_id}")
    except (TypeError, ValueError):
        expected_id = -1 
        print("[‚ùå] TELEGRAM_CHAT_ID in .env is invalid or missing.")
    # --- END DEBUGGING ---

    # Basic authorization check
    if chat_id == expected_id:
        print("[‚úÖ] Chat ID Authorized.")
        if detection_active_event.is_set() and detection_thread and detection_thread.is_alive():
            await update.message.reply_text("Motion detection is already running.")
            return

        # Use the thread-safe wrapper to queue the function call to the main Qt thread
        run_launch_detection_on_main_thread() 

        await update.message.reply_text(
            "Motion detector started remotely. Watch for alerts!"
        )
    else:
        print("[‚ùå] Chat ID Unauthorized.")
        logging.warning(f"Unauthorized access attempt from chat ID: {chat_id}")
        await update.message.reply_text(
            f"Unauthorized access. Your chat ID ({chat_id}) is being logged. Expected ID: {expected_id}"
        )
        
async def stop_command(update, context):
    """Handles the /stop_detector command from Telegram."""
    chat_id = update.message.chat_id
    
    print(f"\n[‚ùì] Received /stop_detector from chat ID: {chat_id}")
    try:
        expected_id = int(TELEGRAM_CHAT_ID)
    except (TypeError, ValueError):
        expected_id = -1 

    # Basic authorization check
    if chat_id == expected_id:
        print("[‚úÖ] Chat ID Authorized.")
        if not detection_active_event.is_set():
            await update.message.reply_text("Motion detection is already idle.")
            return

        # Use the thread-safe wrapper to queue the function call to the main Qt thread
        run_remote_stop_detection_on_main_thread() 

        await update.message.reply_text(
            "Motion detector stopped remotely."
        )
    else:
        print("[‚ùå] Chat ID Unauthorized.")
        logging.warning(f"Unauthorized stop attempt from chat ID: {chat_id}")
        await update.message.reply_text(
            f"Unauthorized access. Your chat ID ({chat_id}) is being logged."
        )

def _build_telegram_app():
    """Builds and configures the Telegram application."""
    app = Application.builder().token(TELEGRAM_TOKEN).build()
    app.add_handler(CommandHandler("start_detector", start_command))
    app.add_handler(CommandHandler("stop_detector", stop_command))
    app.add_handler(CommandHandler("status", status_command))
    app.add_handler(CommandHandler("summary", summary_command))
    return app

async def _start_polling_forever(app):
    """Starts polling and waits indefinitely until cancelled."""
    await app.updater.start_polling()
    await asyncio.Future()  # Keeps the loop alive until app.stop() is called

async def _shutdown_telegram_app(app):
    """Stops the Telegram application cleanly."""
    if app and getattr(app, "running", False):
        await app.stop()
        telegram_app_running = False
    print("[‚úÖ] Telegram application stopped.")
        
def _process_frame_pair(frame1, frame2):
    diff = cv2.absdiff(frame1, frame2)
    gray = cv2.cvtColor(diff, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(gray, (5, 5), 0)
    _, thresh = cv2.threshold(blur, 20, 255, cv2.THRESH_BINARY)
    return np.sum(thresh) > 100000
    

def send_alerts_async(mp4_file):
    def send_telegram(mp4):
        pass
        send_telegram_alert("Motion detected!", mp4)

    def send_fastmail(mp4):
        pass
        send_fastmail_email_with_attachment(
            subject="Motion Alert: Activity Detected",
            body="Motion was detected. See attached video clip.",
            to_email="guneybilen@yahoo.com",
            video_path=mp4_file,
            from_email=os.getenv("FROM_EMAIL"),
            app_password=os.getenv("APP_PASSWORD")
        )

    Thread(target=send_telegram, args=(mp4_file,), daemon=True).start()
    Thread(target=send_fastmail, args=(mp4_file,), daemon=True).start()

def send_telegram_error_alert(message):
    def send_telegram_text(message):
        pass
        """Sends an error message to Telegram."""
        if not TELEGRAM_TOKEN or not TELEGRAM_CHAT_ID:
            logging.error("Telegram credentials missing for error alert.")
            return
        try:
            requests.post(
                f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage",
                data={"chat_id": TELEGRAM_CHAT_ID, "text": f"[ERROR] {message}"},
            )
            logging.info(f"Sent Telegram error alert: {message}")
        except Exception as e:
            logging.error(f"Failed to send Telegram error alert: {e}")
        
    Thread(target=send_telegram_text, args=(message,), daemon=True).start()
     
def send_telegram_alert(message="Motion detected!", video_path=None):
    def send_telegram_alert_text(message, video_path):
        pass
        """Sends a motion notification and optional video to Telegram."""
        if not TELEGRAM_TOKEN or not TELEGRAM_CHAT_ID:
            logging.error("Telegram credentials missing for motion alert.")
            return

        # 1. Send Text Message
        url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
        data = {"chat_id": TELEGRAM_CHAT_ID, "text": message}

        try:
            requests.post(url, data=data)
            print("[‚úî] Telegram text alert sent.")
        except Exception as e:
            print(f"[!] Failed to send Telegram message: {e}")

        # 2. Send Video (if provided)
        if video_path and os.path.exists(video_path):
            url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendVideo"
            try:
                with open(video_path, "rb") as video:
                    files = {"video": video}
                    data = {"chat_id": TELEGRAM_CHAT_ID, "caption": "Motion detected!"}
                    requests.post(url, data=data, files=files)
                    print("[‚úî] Telegram video alert sent.")
            except Exception as e:
                print(f"[!] Failed to send Telegram video: {e}")
    Thread(target=send_telegram_alert_text, args=(message, video_path), daemon=True).start()
    
async def async_run_telegram(telegram_app: Application):
    """CRITICAL: The main async function to initialize and run the Telegram bot."""
    global telegram_bot_running
    
    await telegram_app.initialize()
    
    telegram_bot_running = True
    gui_after(0, update_telegram_status_label)
    
    logging.info("[INFO] Telegram Application is running (manual polling)...")

    await telegram_app.start()
    await telegram_app.updater.start_polling()  # ‚úÖ Manual polling avoids signal setup
    await asyncio.Future()   # Keeps the loop alive until externally stopped

def run_telegram_listener(loop):
    """The main entry point for the Telegram bot thread (synchronous)."""
    global telegram_bot_running, telegram_app, telegram_bot_loop
    telegram_bot_loop = loop # CRITICAL: Store the loop reference
    
    telegram_app = Application.builder().token(TELEGRAM_TOKEN).build()
    
    telegram_app.add_handler(CommandHandler("start", start_command))
    telegram_app.add_handler(CommandHandler("stop", stop_detection_command))
    telegram_app.add_handler(CommandHandler("detect", start_detection_command))

    try:
        # CRITICAL FIX: Run the dedicated async function. 
        # This correctly awaits initialize() and run_polling(stop_signals=None), resolving the 'never awaited' warning.
        loop.run_until_complete(async_run_telegram(telegram_app))
        
    except Exception as e:
        # The exception is often raised when the thread is manually stopped, but 
        # if the bot fails to start, it's a real error.
        logging.error(f"[‚ùå] Telegram listener failed: {e}")
    finally:
        telegram_bot_running = False
        gui_after(0, update_telegram_status_label)
        logging.info("Telegram listener stopped gracefully.")
    
def _handle_motion_event(cap, cooldown):
    """Handles motion detection event safely with debug output."""
    global last_motion_time, motion_count_today
    print("[DEBUG] Handling motion event start")
    try:
        last_motion_time = datetime.now()
        motion_count_today += 1

        avi_file = save_clip(cap)
        if not avi_file:
            print("[!] save_clip returned None ‚Äî aborting motion event")
            return

        print(f"[DEBUG] Saved clip: {avi_file}")
        
        mp4_file = compress_video(avi_file)
        print(f"[DEBUG] Compressed to: {mp4_file}")

        send_alerts_async(mp4_file)
        print("[DEBUG] Telegram alert sent")

        _run_cooldown(cooldown)
        print("[DEBUG] Cooldown completed")
    except Exception as e:
        print(f"[‚ùå] Exception in _handle_motion_event: {e}")
        logging.error(f"Motion event failed: {e}")

def _run_cooldown(seconds):
    for i in range(seconds, 0, -1):
        if not detection_active_event.is_set():
            break
        update_cooldown_label(i)
        time.sleep(1)

    if detection_active_event.is_set() and gui_exists():
        #print(f"_run_cooldown_label function - detection_active_event.is_set(): {detection_active_event.is_set()} and gui_exists(): {gui_exists()}")
        recording_in_progress = True
        cooldown_label.setText("Detecting")
            
@contextmanager
def open_camera(index=0):
    """Context manager for opening and releasing the camera."""
    global cap
    cap = cv2.VideoCapture(index)
    if not cap.isOpened():
        cap.release()
        cap = None
        raise IOError(f"Cannot open camera at index {index}")
    try:
        yield cap
    finally:
        # CRITICAL FIX: The camera resource is NOT released here. 
        # It MUST be released in the main_entry's finally block OR 
        # the detection thread's finally block to avoid premature release.
        pass 


def main():
    recording_event = threading.Event()

    print("[DEBUG] main() started")
    print(f"[DEBUG] detection_active_event: {detection_active_event.is_set()}")

    """Main motion detection loop running in a background thread."""
    global cap, detection_thread
    print("[DEBUG] Detection thread started.")
    logging.info("[üé¨] Detection thread started.")
    

    # Attempt to open camera using context manager
    cap = None
    try:
        with open_camera() as cam:
            if cam is None or not cam.isOpened():
                logging.warning("open_camera() failed. Trying fallback initialization.")
                cam = cv2.VideoCapture(0)
                if not cam or not cam.isOpened():
                    logging.error("Camera initialization failed completely.")
                    if gui_exists():
                        gui_after(0, lambda: cooldown_label.setText("Camera Error"))
                        gui_after(0, lambda: start_button.setEnabled(True))
                    return
                logging.info("Fallback camera initialization succeeded.") 
            cap = cam  # Assign to global cap for use in other functions

            recording_in_progress = False
            last_alert_time = 0
            cooldown = 30
            
            if cap is None or not cap.isOpened():
                logging.error("Camera object is invalid before detection loop.")
                return
                
            while detection_active_event.is_set():
                logging.debug("Detection loop active")
                if cap is None or not hasattr(cap, 'read'):
                    logging.error('Camera object lost or invalid. Exiting detection loop.')
                    break

                ret1, frame1 = cap.read()
                time.sleep(0.05)
                ret2, frame2 = cap.read()

                if not ret1 or not ret2:
                    time.sleep(1)
                    continue

                if _process_frame_pair(frame1, frame2):
                    #print("[DEBUG] Motion detected")
                    now = time.time()

                    if now - last_alert_time > cooldown and not recording_event.is_set():
                        recording_event.set()
                        last_alert_time = time.time()  # ‚úÖ Move this up
                        _handle_motion_event(cap, cooldown)
                        recording_event.clear()
                        logging.info(f"[‚úî] Motion recorded. Cooldown started.")
                    elif recording_event.is_set():
                        logging.info("[‚è≥] Motion detected but already recording.")
                    else:
                        logging.info("[‚è≥] Motion detected but cooldown is active.")



    except Exception as e:
        logging.exception(f"Detection thread crashed: {e}")

    # Cleanup after loop exits
    if cap:
        cap.release()
        cap = None
    detection_active_event.clear()
    logging.info("Detection thread exited. Resetting detection_active_event.")
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    send_telegram_error_alert(f"‚ö†Ô∏è Detection thread exited at {timestamp}. Motion detection is OFF.")
    if gui_exists():
        update_gui_idle_state()
    print("[‚úÖ] Detection thread terminated.")
    detection_thread = None

def build_gui_commands():
    def toggle_daily_summary():
        global daily_summary_enabled
        daily_summary_enabled = not daily_summary_enabled
        status = "enabled" if daily_summary_enabled else "disabled"
        logging.info(f"Daily summary {status} by user.")
        QMessageBox.information(main_window, "Daily Summary", f"Daily summary has been {status}.")

    def clear_logs():
        answer = QMessageBox.question(main_window, "Confirm", "Are you sure you want to clear the log file?",
                                      QMessageBox.Yes | QMessageBox.No)
        if answer == QMessageBox.Yes:
            try:
                with open("motion_log.txt", "w") as f:
                    f.write("")
                logging.info("Log file cleared by user.")
                print("[üßπ] Log file cleared.")
                QMessageBox.information(main_window, "Cleared", "Log file cleared.")
            except Exception as e:
                logging.error(f"Failed to clear log file: {e}")
                QMessageBox.critical(main_window, "Error", f"Could not clear log file:\n{e}")

    def send_summary_now():
        send_daily_summary()
        QMessageBox.information(main_window, "Summary Sent", "Motion summary has been sent.")

    def open_clips_folder():
        folder_path = os.path.abspath("clips")
        system = platform.system()
        try:
            if system == "Windows":
                os.startfile(folder_path)
            elif system == "Darwin":
                subprocess.Popen(["open", folder_path])
            else:
                subprocess.Popen(["xdg-open", folder_path])
            print("[üìÇ] Opened clips folder.")
        except Exception as e:
            print(f"[!] Failed to open folder: {e}")

    def open_log_file():
        log_path = os.path.abspath("motion_log.txt")
        system = platform.system()
        try:
            if system == "Windows":
                os.startfile(log_path)
            elif system == "Darwin":
                subprocess.Popen(["open", log_path])
            else:
                subprocess.Popen(["xdg-open", log_path])
            print("[üìñ] Opened log file.")
        except Exception as e:
            print(f"[!] Failed to open log file: {e}")

    return {
        "toggle_daily_summary": toggle_daily_summary,
        "clear_logs": clear_logs,
        "send_summary_now": send_summary_now,
        "open_clips_folder": open_clips_folder,
        "open_log_file": open_log_file,
    }

def build_gui_widgets(commands):
    global start_button, stop_button, cooldown_label, autostart_status_label, widgets, autostart_status_label, video

    start_button = QPushButton("Start Detection")
    start_button.clicked.connect(launch_detection)

    stop_button = QPushButton("Stop Detection")
    stop_button.clicked.connect(stop_detection)
    stop_button.setEnabled(False)

    cooldown_label = QLabel("Idle")
    cooldown_label.setAlignment(Qt.AlignCenter)

    autostart_status_label = QLabel("Autostart")
    autostart_status_label.setStyleSheet("background-color: green; padding:4px;")
    autostart_status_label.setAlignment(Qt.AlignCenter)

    clear_button = QPushButton("Clear Logs")
    clear_button.clicked.connect(commands["clear_logs"])

    summary_button = QPushButton("Send Summary")
    summary_button.clicked.connect(commands["send_summary_now"])

    toggle_summary_button = QPushButton("Toggle Daily Summary")
    toggle_summary_button.clicked.connect(commands["toggle_daily_summary"])

    open_clips_button = QPushButton("Open Clips Folder")
    open_clips_button.clicked.connect(commands["open_clips_folder"])

    open_log_button = QPushButton("Open Log File")
    open_log_button.clicked.connect(commands["open_log_file"])
    

    telegram_help_label = QLabel(
        "Telegram Commands:\n"
        "/start_detector ‚Äì Start detection\n"
        "/stop_detector ‚Äì Stop detection\n"
        "/status ‚Äì System status\n"
        "/summary ‚Äì Motion summary"
    )
    telegram_help_label.setAlignment(Qt.AlignLeft)
    telegram_help_label.setWordWrap(True)
    telegram_help_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

    telegram_status_label = QLabel("Telegram Bot: Unknown")
    telegram_status_label.setAlignment(Qt.AlignCenter)
    telegram_status_label.setStyleSheet("color: darkred; font-weight: bold;")
    
    video = QLabel()
    video.setAlignment(Qt.AlignCenter)
    video.setFixedSize(640, 480)  # or your camera size
    video.setStyleSheet("background-color: black;")

    widgets = {
        "start": start_button,
        "stop": stop_button,
        "cooldown": cooldown_label,
        "autostart": autostart_status_label,
        "clear": clear_button,
        "summary": summary_button,
        "toggle_summary": toggle_summary_button,
        "open_clips": open_clips_button,
        "open_log": open_log_button,
        "telegram_help": telegram_help_label,
        "telegram_status": telegram_status_label, 
        "video_label": video
    }

    return widgets

class MainWindow(QMainWindow):
    def __init__(self, commands):

        super().__init__()
        self.setWindowTitle("Motion Detector")
        central = QWidget()
        layout = QVBoxLayout()
        self.widgets = build_gui_widgets(commands)

        # Add widgets to layout (order similar to original)
        layout.addWidget(self.widgets["start"])
        layout.addWidget(self.widgets["stop"])
        layout.addWidget(self.widgets["cooldown"])
        layout.addWidget(self.widgets["autostart"])
        layout.addWidget(self.widgets["clear"])
        layout.addWidget(self.widgets["summary"])
        layout.addWidget(self.widgets["toggle_summary"])
        layout.addWidget(self.widgets["open_clips"])
        layout.addWidget(self.widgets["open_log"])
        layout.addWidget(self.widgets["telegram_help"])
        layout.addWidget(self.widgets["telegram_status"])
        layout.addWidget(self.widgets["video_label"])
        layout.addStretch()

        central.setLayout(layout)
        self.setCentralWidget(central)
        
    def closeEvent(self, event):
        global telegram_bot_loop
        
        try:
            # Shutdown Telegram bot
            if telegram_bot_loop and telegram_bot_loop.is_running():
                asyncio.run_coroutine_threadsafe(shutdown_telegram_listener(), telegram_bot_loop)
            else:
                asyncio.run(shutdown_telegram_listener())
        except Exception as e:
            logging.warning(f"Telegram shutdown failed: {e}")

        # Join Telegram thread
        if telegram_thread and telegram_thread.is_alive():
            telegram_thread.join(timeout=5)

        # Join detection thread
        if detection_thread and detection_thread.is_alive():
            detection_thread.join(timeout=5)

        # Join watchdog thread if you have one
        watchdog_stop_event.set()

        release_camera_resource()
        
        for t in active_timers:
            if t.is_alive():
                logging.info(f"[TIMER] Joining active timer: {t}")
                t.join(timeout=2)
        
        shutdown_gui()

        logging.info("[üõë] Application closed via GUI.")
        QApplication.quit()  
        event.accept() # Let Qt handle the close
        time.sleep(1)
        #logging.info(f"Active threads at shutdown: {threading.enumerate()}")
        sys.exit(0)
          
def create_gui():

    global app, main_window, widgets, on_close

    if QApplication.instance() is None:
        app = QApplication(sys.argv)
    else:
        app = QApplication.instance()

    logging.info("GUI launched. Entering main loop.")

    commands = build_gui_commands()
    main_window = MainWindow(commands)
    widgets = main_window.widgets

    def schedule_telegram_status_updates():
        update_telegram_status_label()
        if gui_exists():
            gui_after(5000, schedule_telegram_status_updates)

    schedule_telegram_status_updates()

    logging.info("GUI created and initialized.")
    return main_window

def setup_signal_handlers():
    signal.signal(signal.SIGINT, force_exit)
    signal.signal(signal.SIGTERM, force_exit)

def start_telegram_listener_thread():
    """Starts the Telegram listener in a new thread with its own asyncio loop."""
    global telegram_thread, telegram_bot_loop
    if not TELEGRAM_TOKEN or not TELEGRAM_CHAT_ID:
        logging.warning("Telegram listener skipped: missing TELEGRAM_TOKEN or TELEGRAM_CHAT_ID")
        return

    def start_telegram_thread_sync():
        """Function executed by the new thread."""
        new_loop = asyncio.new_event_loop()
        asyncio.set_event_loop(new_loop)
        run_telegram_listener(new_loop)

    try:
        telegram_thread = threading.Thread(target=start_telegram_thread_sync, daemon=True)
        telegram_thread.start()
        logging.info("[‚úÖ] Telegram loop created and set in background thread.")
    except Exception as e:
        logging.error(f"Failed to start Telegram thread: {e}")

def run_initial_setup():
    clean_old_clips()
    schedule_daily_summary()

def initialize_gui():
    global main_window
    main_window = create_gui()
    return main_window

def init_widgets_for_boot():
    #print(f"gui_exists() return is: {gui_exists()}")
    if gui_exists():
        start_button.setEnabled(False)
        stop_button.setEnabled(True)
        cooldown_label.setText("Detecting...")

def handle_autostart():
    global autostart_animation_active
    
    if detection_active_event.is_set():
        detection_active_event.set()

    if autostart_enabled:
        print("[‚úÖ] Autostart is ON. Launching detection.")
        launch_detection()
        
        autostart_animation_active = True
        animate_autostart_indicator()
        gui_after(10000, stop_autostart_animation)

def run_main_loop(window):
    logging.info("Main loop started.")
    if app:
        window.show()
        app.exec_()
        
        # --- Telegram Bot Handlers ---
        
async def stop_detection_command(update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the /stop command."""
    if detection_active_event.is_set():
        shutdown_detection_pipeline(remote=True)
        await update.message.reply_text('Motion detection stopped remotely.')
    else:
        await update.message.reply_text('Motion detection is already stopped.')

async def start_detection_command(update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the /start command."""
    if not detection_active_event.is_set():
        launch_detection(remote=True)
        await update.message.reply_text('Motion detection started remotely.')
    else:
        await update.message.reply_text('Motion detection is already running.')

        
def run_watchdog():
    """
    CRITICAL: The watchdog loop now respects the global stop event.
    """
    global watchdog_thread, telegram_thread, detection_thread, watchdog_stop_event
    logging.debug("[üëÅÔ∏è] Watchdog started.")
    
    while not watchdog_stop_event.is_set():
        # Check Telegram thread health
        if telegram_thread and not telegram_thread.is_alive() and telegram_bot_running:
            logging.error("Telegram thread crashed. Restarting...")
            start_telegram_listener_thread()
            
        # Check Detection thread health
        if detection_thread and not detection_thread.is_alive() and detection_active_event.is_set():
            logging.error("Detection thread crashed. Restarting...")
            launch_detection()

        watchdog_stop_event.wait(10) # Wait 10 seconds or until stop event is set
        
    logging.debug("[üëÅÔ∏è] Watchdog terminated.")
        
def stop_telegram_listener():
    """CRITICAL: Signals the Telegram bot application to stop gracefully."""
    global telegram_thread, telegram_app, telegram_bot_loop
    if telegram_thread and telegram_thread.is_alive():
        logging.info("Signaling Telegram bot to stop...")
        
        # 1. Stop the application from its own event loop context
        if telegram_app and telegram_bot_loop:
            try:
                # Schedule the async stop method to run on the bot's event loop
                telegram_bot_loop.call_soon_threadsafe(lambda: asyncio.run_coroutine_threadsafe(telegram_app.stop(), telegram_bot_loop))
            except Exception as e:
                logging.error(f"Error signaling Telegram application stop: {e}")
                
        # 2. Join the thread
        telegram_thread.join(timeout=5)
        if telegram_thread and telegram_thread.is_alive():
            logging.critical("Telegram thread failed to terminate after signal!")
            return False
        
        logging.info("Telegram listener stopped.")
        return True
    return False

def main_entry():
    """The main application entry point."""
    global telegram_thread, watchdog_thread, watchdog_stop_event

    # Basic Logging Setup (Ensure this runs first)
    log_file = os.path.join(os.getcwd(), 'motion_log.txt')
    logging.basicConfig(
        level=logging.DEBUG, 
        format='%(asctime)s [%(levelname)s] %(message)s',
        handlers=[
            logging.StreamHandler(sys.stdout),
            TimedRotatingFileHandler(log_file, when='midnight', interval=1, backupCount=7)
        ]
    )
    logging.info("-" * 50)
    logging.info(f"Application starting at {datetime.now()}")
    
    setup_signal_handlers()
    # Threads must be started before the GUI blocks the main thread
    start_telegram_listener_thread() 
    run_initial_setup()
    start_watchdog() 

    try:
        window = initialize_gui()
        handle_autostart()
        run_main_loop(window)
        
    except Exception as e:
        logging.critical(f"Main GUI execution failed: {e}", exc_info=True)
        
    finally:
        # CRITICAL: NEW GRACEFUL SHUTDOWN SEQUENCE
        logging.info("Initiating application shutdown sequence...")
        
        # 1. Stop Detection (if running)
        shutdown_detection_pipeline(remote=False) 
        
        # 2. Stop Watchdog thread
        if watchdog_thread and watchdog_thread.is_alive():
            logging.info("Stopping Watchdog thread...")
            watchdog_stop_event.set() # Set the event to break the watchdog loop
            watchdog_thread.join(timeout=5)
            if watchdog_thread and watchdog_thread.is_alive():
                 logging.critical("Watchdog thread failed to terminate within 5s!")
            watchdog_thread = None
        
        # 3. Stop Telegram thread
        if telegram_thread and telegram_thread.is_alive():
            stop_telegram_listener() # Handles signaling the loop to stop and joining
            telegram_thread = None
        
        logging.info("Application closed successfully. Goodbye.")

    
if __name__ == "__main__":
    logging.info("Starting motion detector system...")
    main_entry()
